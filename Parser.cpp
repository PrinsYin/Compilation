#include<iostream>
#include<vector>
#include<set>
#include<string>
#include<fstream>
#include<map>
#include <stdlib.h> 
#include<algorithm>
#include"parser.h"
using namespace std;

/**
 * getStrFIRST 给定产生式右部的符号集合，返回它们的FIRST集。
 * @param Ba 一个字符串向量，代表产生式右部的符号集合。
 * @return 返回计算得到的FIRST集，它是一个字符串集合。
 */

set<string> Parser::getStrFIRST(const vector<string>& Ba)
{
	set<string> res;
	if (Ba.size() == 0)
	{
		return res;
	}
	else
		return FIRST[Ba[0]];
}

/**
 * Parser 初始化解析器，并加载给定的文法文件。
 * @param filename 文法文件的路径。
 */
Parser::Parser(const string& filename)
{
	errorLine = 0;
	errorToken = "";///？？？？？？？？？？？？？？？？？？

	loadGrammar(filename);
	getVN();
	getVT();
	getFIRST();
	getLR1States();
	getACTION();
	getGOTO();

}

/**
 * loadGrammar 从给定的文件中加载文法。
 * @param filename 文法文件的路径。
 * @return 如果文件加载成功，则返回true，否则返回false。
 */
bool Parser::loadGrammar(const string& filename)
{
	// 打开文件
	string line, str;
	Grammar g;
	ifstream file(filename, ios::binary | ios::in);
	if (!file.is_open())
		return false; // 文件打开失败，返回失败标志

	// 临时变量和结构体的声明
	

	// 逐行读取文件内容
	while (getline(file, line))
	{
		
		if (line.empty())
			continue;
		g.right.clear();
		stringstream lstream(line);
		lstream >> g.left;
		lstream >> str;
		while (lstream >> str)
		{
			g.right.push_back(str);
		}
		rules.push_back(g);
	}

	// ?????????????????
	g.right.clear();
	g.left = rules[0].left + EXT_CHAR;
	g.right.push_back(rules[0].left);
	rules.insert(rules.begin(), g);

	return true; 
}



/**
 * getVN 从给定的文法中获取所有的非终结符，并存储到VN集合中。
 */
void Parser::getVN()
{
	for (const auto& rule : rules)
		VN.insert(rule.left);
}

/**
 * getVT 从给定的文法中获取所有的终结符，并存储到VT集合中。
 */
void Parser::getVT()
{
	for (auto& rule : rules)
	{
		for (auto& ri : rule.right)
			if (!VN.count(ri))
				VT.insert(ri);
	}
	VT.insert("#");//空
}

/**
 * getFIRST 计算和存储所有非终结符的FIRST集。
 */
void Parser::getFIRST()
{
	for (const auto& vt : VT) {
		FIRST[vt] = { vt };
	}

	vector<int> list;	//记录产生式右部第一个符号为非终结符的文法
	for (auto it = rules.begin(); it != rules.end(); ++it)
	{
			string first = it->right.front();
			if (VT.count(first))
				FIRST[it->left].insert(first);
			else
				list.push_back(distance(rules.begin(), it));
	}

	bool flag,ep;
	while (1) {
		flag = false;
		for (const auto& i : list) {
			ep = false;
			for (const auto& elem1 : rules[i].right)
			{
				ep = false;
				if (VN.count(elem1))
				{
					//考虑A->A..的特殊情况
					if (rules[i].left == elem1) {
							break;
					}
					//若出现A->B...,则将B的first集全部加到A中
					for (const auto& elem2 : FIRST[elem1]) 
						if (FIRST[rules[i].left].insert(elem2).second) 
							flag = true;
					if (!ep)
						break;	//若不含空,则后续不用继续加入
				}//?????????????????????????ep????????
				else
					break;
			}

		}
		if (!flag)	//如果first集不再增加,则返回
			break;
	}
}

/**
 *getCLOSURE 根据给定的项目集I，计算它的闭包。
 * @param I 项目集，它是一个Project类型的集合，Project可能是一个包含产生式索引、点的位置和follow set的结构体或类。
 * @return 返回计算得到的闭包，它是一个Project类型的集合。
 */

set<Project> Parser::getCLOSURE(const set<Project>& I)
{

	set< Project > closure(I);			//project_set自身的所有项目都在闭包中
	set<Project> old_project(I);	//辅助集合
	set<Project> new_project;
	int before = 0,after=0;
	bool flag;
	while (true) {
		before = old_project.size();
		flag = false;
		for (const auto& i : old_project) {	//扫描上一次产生的所有项目
			Grammar rule = rules[i.index];
			if (rule.right.size() > i.point && VN.count((rule.right[i.point]))) //为非终结符且不是最后一个符号
			{
				//A->α.Bβ型
				string B = rule.right[i.point];
				//求出first(βa)
				set<string> firstAfterDot;
				vector<string> symbolsAfterDot;

				
				for (auto symbol = rules[i.index].right.begin() + i.point + 1; symbol != rules[i.index].right.end(); symbol++)
				{
					symbolsAfterDot.push_back(*symbol);
				}
				if(symbolsAfterDot.size() == 0)
				{
					for (const auto& follow : i.follow)
						firstAfterDot.insert(follow);
				}
				else
					firstAfterDot=FIRST[symbolsAfterDot[0]];//???????????

				for (int j = 0; j < rules.size(); j++) 
				{
					//扫描所有B->γ型的产生式
					if (rules[j].left == B) {
						//若CLOSURE中不存在{B->γ,firstba},则加入
						bool flag1 = false;
						for (auto it = closure.begin(); it != closure.end(); ++it) {
							if (it->index == j && it->point == 0) {
								//项目在集合
								flag1 = true;
								set<string>temp;
								set_intersection(it->follow.begin(), it->follow.end(), firstAfterDot.begin(), firstAfterDot.end(), inserter(temp, temp.begin()));
								if (temp!=firstAfterDot) {
									//若follows不完整,则插入新的follows
									flag = true;
									//由于集合元素的值无法修改,故只能覆盖之
									auto ngp = *it;
									for (auto firstba_elem : firstAfterDot)
										ngp.follow.insert(firstba_elem);
									closure.erase(it);
									closure.insert(ngp);
									new_project.insert(ngp);
								}
								break;
							}
						}
						if (!flag1) {
							//否则插入新项目
							flag = true;
							closure.insert({ j,0,firstAfterDot });
							new_project.insert({ j,0,firstAfterDot });
						}
					}
				}
			}
		}
		after = new_project.size();
		if (!flag)	//不再增加,则返回
			break;
		old_project = new_project;	//对新添加项目进行下一轮扫描
		new_project.clear();
	}

	return closure;
	
}


/**
 * getLR1States 计算LR(1)项目集的规范族。
 * @return 返回一个映射，其中的键是各个项目集的名称，如"I0"、"I1"等，值是对应的项目集。
 */
map <string, set<Project>> Parser::getLR1States()
{
	set<string> tmp = { "#" };
	map <string, set<Project>> ProjectSet;
	set<set<Project>> C_sup;
	vector <set<Project> >C;

	Project init = { 0,0,tmp };
	set<Project> _GO, J = { init };
	_GO = getCLOSURE(J);
	C.emplace_back(_GO);
	C_sup.insert(J);
	ProjectSet["I0"] = C[0];
	int num = 1;

	for (auto i = 0; i < C.size(); i++)
	{
		for (auto& vn : VN)//非终结符
		{
			J.clear();
			for (auto& elem : C[i])//遍历每一个项目
			{
				for (auto j = 0; j < rules[elem.index].right.size(); j++)//找到项目中类似A->・vn的
				{
					if (rules[elem.index].right[j] == vn && elem.point == j)//找到
					{
						J.insert({ elem.index,elem.point + 1,elem.follow });//点后移
						break;
					}

				}
			}
			_GO = getCLOSURE(J);    //获得GO（C[i],vn）
			if (_GO.size() > 0)    //不为空集
			{
				if (!C_sup.count(_GO))
				{
					GO[{"I" + to_string(i), vn}] = "I" + to_string(num);
					C.emplace_back(_GO);
					C_sup.insert(_GO);
					ProjectSet["I" + to_string(num++)] = _GO;
				}
				else
				{
					vector<set<Project>>::iterator it = find(C.begin(), C.end(), _GO);
					vector<set<Project>>::iterator begin = find(C.begin(), C.end(), C.front());
					int index = it - begin;
					GO[{"I" + to_string(i), vn}] = "I" + to_string(index);
				}
			}
			else
				GO[{"I" + to_string(i), vn}] = "error";
		}

		for (auto& vt : VT)
		{
			J.clear();
			for (auto& elem : C[i])
			{
				for (int j = 0; j < rules[elem.index].right.size(); j++)
				{
					if (rules[elem.index].right[j] == vt && elem.point == j)
					{
						J.insert({ elem.index,elem.point + 1,elem.follow });
						break;
					}

				}
			}
			_GO = getCLOSURE(J);
			if (_GO.size() > 0)    //不为空集
			{
				if (!C_sup.count(_GO))
				{
					GO[{"I" + to_string(i), vt}] = "I" + to_string(num);
					C.emplace_back(_GO);
					C_sup.insert(_GO);
					ProjectSet["I" + to_string(num++)] = _GO;
				}
				else
				{
					vector<set<Project>>::iterator it = find(C.begin(), C.end(), _GO);
					vector<set<Project>>::iterator begin = find(C.begin(), C.end(), C.front());
					int index = it - begin;
					GO[{"I" + to_string(i), vt}] = "I" + to_string(index);
				}
			}
			else
				GO[{"I" + to_string(i), vt}] = "error";
		}
	}
	lr1states = C;
	return ProjectSet;
}


/**
 * getACTION 构建LR(1)解析表的ACTION部分。在执行此函数后，解析器的ACTION表应为最新状态。
 */
void Parser::getACTION()
{
	for (int i = 0; i < lr1states.size(); i++)
	{
		for (auto item : lr1states[i])
		{
			//接受
			if (rules[item.index].left == string(START) + EXT_CHAR && rules[item.index].right.front() == START && rules[item.index].right.size() == item.point)
			{
				ACTION[{"I" + to_string(i), "#"}] = "acc";
			}
			//移进
			else if (rules[item.index].right.size() > item.point)
			{
				string var = rules[item.index].right[item.point];
				if (VT.count(var))//是终结符
				{
					string tmp = GO[{"I" + to_string(i), var}];
					if (tmp != "error")
						tmp = GO[{"I" + to_string(i), var}].substr(1, tmp.length());
					ACTION[{"I" + to_string(i), var}] = string("s") + tmp;
				}
			}
			//规约
			else
			{
				for (auto fol : item.follow)
				{
					ACTION[{"I" + to_string(i),fol}] = string("r") + to_string(item.index);
				}
			}
		}
	}
	//不能填表的全赋为error
	for (int i = 0; i < lr1states.size(); i++)
	{
		for (auto vt : VT)
			if (ACTION[{"I" + to_string(i), vt}] == "")
				ACTION[{"I" + to_string(i), vt}] = "error";
	}
}


/**
 * getGOTO 构建LR(1)解析表的GOTO部分。在执行此函数后，解析器的GOTO表应为最新状态。
 */
void Parser::getGOTO()
{
	for (auto vn : VN)
	{
		for (int i = 0; i < lr1states.size(); i++)
		{
			GOTO[{"I" + to_string(i),vn}] = GO[{"I" + to_string(i), vn}];
		}
	}
}

/**
 * tryParse() 尝试解析给定的字符串。
 *
 * @param LexResStr 将要被解析的字符串。
 * @param fin 文件流。
 * @param fout 文件流。
 * @return 如果解析成功，返回 "Accept!!!"；如果解析出错，返回错误信息。
 */

string Parser::tryParse(const string& LexResStr, ifstream& fin, ofstream& fout,string code_file_name)
{
	
	Lex L(code_file_name, "lexerout.txt");
	L.scan(fin,fout);  // 打开词法分析器，处理输入字符串
	// 变量初始化
	int line = 1;
	vector<int> state;
	vector<pair<string, string>> symbol;
	pair<string, string> nextToken;
	pair<string, string> token = L.GetNextToken();  // 获取第一个令牌

	pair<string, string> bubble = pair<string, string>("none", "none");
	TreeNode* tp = nullptr;
	stack<TreeNode*> treeNodeStack;
	fstream fp("parser.txt", ios::out | ios::binary);

	// 初始压栈
	state.push_back(0);
	symbol.push_back(pair<string, string>(string("#"), string("#")));
	// 循环语法分析
	while (token.first != "ERROR") 
	{
		if (token.first == "NL") {
			line++;
			token = L.GetNextToken();
			continue;
		}

		if (find(VT.begin(), VT.end(), token.second) == VT.end())//如果不是止符，报错
		{
			string msg = string("ERROR: ") + (token.second) + string(" is not a terminator.\n");
			fp << msg << endl;
			fp.close();
			return msg;
		}

		// 动作状态机
		string action = ACTION[{"I" + to_string(state.back()), token.second}];
		if (action == "acc") {  // 如果动作是“接受”，则接受输入并返回
			fp << "词法 / 语法分析成功，语法树已输出到tree文件，graphviz格式" << endl;
			fp.close();
			root = tp;
			return "Accept!!!";
		}
		if (action == "error")
		{
			if (token != bubble) 
			{
				nextToken = token;
				token = bubble;
			}
			else 
			{
				string msg;
				msg = string("ERROR: Parser detected error on line ") + to_string(line) + string(" (") + token.second + string(").\n");
				fp << msg << endl;
				fp.close();
				return msg;
			}
		}
		if (action.substr(0, 1) == "s")  // 如果动作是“移进”，则将新状态和令牌压入堆栈，并获取下一个令牌
		{
			tp = new(nothrow)TreeNode;
			if (!tp) {
				string msg;
				msg = string("ERROR: Memory crashed on line ") + to_string(line) + string(" (") + token.second + string(").\n");
				fp << msg << endl;
				fp.close();
				return msg;
			}
			tp->data = { token.first,1 };
			treeNodeStack.push(tp);

			state.push_back(atoi(action.substr(1, action.length()).c_str()));
			symbol.push_back(token);

			if (token == bubble)
				token = nextToken;
			else
				token = L.GetNextToken();
		}
		if (action.substr(0, 1) == "r")  // 如果动作是“归约”，则根据规则从堆栈中弹出符号和状态，并将结果压入堆栈
		{
			int index = atoi(action.substr(1, action.length()).c_str());
			int length = rules[index].right.size();
			for (int i = length - 1; i >= 0; i--) {
				if (symbol.back().second== rules[index].right[i]) {
					symbol.pop_back();
					state.pop_back();
				}
				else {
					string msg;
					msg = string("ERROR: Parser detected error on line ") + to_string(line) + string(" (") + token.second + string(").\n");
					msg += string("-Note：") + symbol.back().second + string(" is different from ") + rules[index].right[i] + string(".\n");
					fp << msg << endl;
					fp.close();
					return msg;
				}
			}
			/// 树
			string token_t = rules[index].left + " ->";
			for (int i = 0; i < length; i++) {
					token_t += " " + rules[index].right[i];
			}
			fp << "lexer:" << token.first << "  action:" << action << "  production:" << token_t << endl;
			tp = new(nothrow)TreeNode;
			if (!tp) {
				string msg;
				msg = string("ERROR: Memory crashed on line ") + to_string(line) + string(" (") + token.first + string(").\n");
				fp << msg << endl;
				fp.close();
				return msg;
			}
			tp->data = pair<string, int>(rules[index].left, -1);
			for (int i = 0; i < length; i++) {
				treeNodeStack.top()->parent = tp;
				tp->children.push_back(treeNodeStack.top());
				treeNodeStack.pop();
			}
			reverse(tp->children.begin(), tp->children.end());
			treeNodeStack.push(tp);

			symbol.push_back(pair<string, string>(rules[index].left, rules[index].left));
			state.push_back(atoi(GOTO[{"I" + to_string(state.back()), symbol.back().second}].substr(1, GOTO[{"I" + to_string(state.back()), symbol.back().second}].length()).c_str()));
		}
	};
	return "error";
}



/**
 * GetTree() 递归地获取语法树的所有节点和边，存储在一个文件中。
 *
 * @param fp fstream类型的引用，表示用来存储生成的语法树的文件流。
 * @param p TreeNode类型的指针，表示当前处理的节点。
 */

void Parser::GetTree(fstream &fp,TreeNode* p)
{
	static int i = 0;
	if (p) {
		string tmp = p->data.first;
		if (tmp == "{" || tmp == "}" || tmp == ">" || tmp == "<=")
			tmp = "\\" + tmp;
		fp << "node" + to_string(i) + "[label = \"" << tmp << "\"];\n";
		p->data.second = i++;
		if (p->parent)
			fp << "node" + to_string(p->parent->data.second) + "->node" + to_string(p->data.second) << ";" << endl;

		for (auto child : p->children)
		{
			GetTree(fp, child);
		}
	}
}

/**
 * drawTree() 使用Graphviz工具绘制语法树并保存到一个文件中。
 *
 * @param root TreeNode类型的指针，表示语法树的根节点。
 */
void Parser::drawTree(TreeNode* root)
{
	fstream fp("tree.dot", ios::binary | ios::out);
	fp << "digraph g{" << endl;
	fp << "splines = \"line\";\nnode[shape = record, height = .1]; " << endl;
	TreeNode* p = root;
	GetTree(fp, root);
	fp << "}" << endl;
	fp.close();
}
